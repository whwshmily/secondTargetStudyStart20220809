设计模式

1.单例模式: 只有一个实例化  私有化构造器
  懒汉式 饿汉式(要加volatile 防止指令重排 拿到半初始化对象) DCL(两次检验) 枚举 静态内部类(使用时加载 比较完美 只加载一次 不用加锁)

2.策略模式: 例如排序 传进来的比较器
  定义一个规则规范，在这个规范内的具体的实现是一种策略 ---理解的有歧义 设计模式多是多态的一种运用
  在坦克大战中 子弹的打出可以是一种策略  可以一次打出一个 多个 炮弹等等
  电脑坦克的产生是一种策略 一次出现几个

3.工厂系列 工厂方法 抽象工厂
  任何可以产生对象的方法或类 都可以称为工厂 单例也可以说是一种工厂 不可以咬文嚼字
  为什么有了new 还要有工厂？ 为了更灵活 产生对象交给工厂 定制可以更自由更灵活

  简单工厂:可以定制化创建对象 多个 public T createT(){}
  工厂方法:专门定制某一对象  只生产一种产品的抽象工厂
  抽象工厂: 定制化一系列对象的组合 一族 打包销售
  从语义上:属性抽象成接口 实物之类的抽象类比较好 名称抽象类 形容词接口

4.门面模式 由一个门面去协调所有的关系 当你想访问某一关系的时候 只需要访问门面就可以了
5.调停者模式 这些关系可能互相之间又要打交道 这时有一个关系专门处理关系之间的打交道
这两个模式----消息中间件 面板不和坦克 子弹 爆炸 墙等等其他物品直接联系 全部交给face门面处理
这些物品之间交互也不互相接触 全部交给gameObject处理 调停者模式
这样理解face相当于中间件 gameObject相当于消息 要互相接触时就仍一个gameObject消息到face
然后在消息的订阅方收到消息在自己处理

6.责任链模式 一个定义链里面元素的规则 一个链的对象 链可以实现里面元素的规则(也可以不实现 具体灵活运用)
如果有需要检测的元素 可以经过整个链的里面元素检测是否符合 可以自己定义是否停止 具体灵活运用
Filter 过滤器 拦截器都是这个模式灵活的运用

7.装饰者模式 装饰者包装某一个需要装饰的对象 然后需要装饰的对象还继续按照它以前的逻辑继续执行，不同的装饰器
装饰自己需要的东西 如果想装饰器之间也可以继续装饰 那装饰器和要装饰的对象有共同的父类
不严格模式下 IO流是一种装饰者模式

8.观察者模式 事件源对象(被观察对象) 观察者定义(接口定义 规则) 事件处理封装(当源对象触发观察者事件封装一系列属性 不同的观察者
根据事件做出不同的处理) 例如  observer listener(监听器) Hook(钩子) callback

9.组合模式 company  树状结构 一个节点 叶子节点(根节点) 分支节点(里面可以有叶子和分支节点 里面组合了节点的list)
组合模式 目录 一层有一层

10.享元模式 flyweight 多个共享对象重复利用 池化思想
 就是把一系列对象缓存起来 用的时候不new 直接拿起来用 例如 String里面的缓存 Integer 里面的缓存(我自己猜的)
有些享元模式会把组合模式结合起来用 图形 单个的缓存(例如三角形是一个对象 长方性是一个对象) 组合(这两个组合一起)
组合一起缓存起来 这样组合的时候就会用到组合模式

11.静态代理 用一个对象聚合一个你要代理的对象 这样别人想要做的事情通过你这个代理去做
但是这样别人会感知被代理的 你需要和你代理的对象实现共同的接口(同一个父类) 做的事情是同一件事件
这样别人感知不到 但是不同的代理之间(代理的都是同一种对象)不能代理 所以聚合的对象是父类(共同的接口)
和装饰者很像

12.动态代理JDK自带 Proxy.newProxyInstance() 里面有三个参数
第一个 类加载器 classLoad 第二个 被代理的类实现了哪些接口 class[]
第三个 接口InvocationHandler 当代理出来的类调用其中的某个方法被调用时 应该执行什么操作
JDK代理的对象必须是一个接口
当你使用生成代理的对象调用方法时 会调用接口InvocationHandler的invocate方法
asm实现的生成代理的对象
cglib动态代理 不能代理final修饰的类

13.迭代器模式 集合的迭代器

14.visitor 访问者 结构固定 例如 组装一台电脑 电脑有 CPU 内存 等等  不同的人来组装不同的价格
CPU(里面有一个方法 visitor.visitorCpu(this) 获取cpu的对象) 内存对象 等 visitor实现不同对象不同的访问方法获取对象 不能一直增加对象 这样visitor要一直
增加方法 这样不同的visitor就获取不同的对象 例如classVisitor

15.builder 构建器 分类复杂的对象的构建和表示 同样的构建过程创建不同的表示 无需记忆 自然使用
用于构建复杂的对象 常配合链式编程 builder.buildyyy.buildzzz.build()

16.adapter 接口转换器 适配器 当一个类不能直接访问时 通过adapter访问
例如 充电器是typec的 你的手机不是 不能直接充电 可以使用转换器 转成你需要的
例如 inputstream 只能读一个 不能读一行 bufferreader 读一行 经过转换的
sqlserver是微软的 暴露的是ODBC java是JDBC 不能直接连 经过adapter
常见的adapter不是适配器模式

17.bridge桥接模式 分离抽象与具体  用聚合的方式(桥)连接抽象和具体
抽象和具体两个维度同时发展 互不影响 抽象里面聚合一个具体的实现类

18.command 命令模式 封装命令 实现do和undo(返回上一步 例如idea的ctrl+z)