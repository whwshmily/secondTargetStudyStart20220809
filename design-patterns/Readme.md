设计模式

1.单例模式: 只有一个实例化  私有化构造器
  懒汉式 饿汉式(要加volatile 防止指令重排 拿到半初始化对象) DCL(两次检验) 枚举 静态内部类(使用时加载 比较完美 只加载一次 不用加锁)

2.策略模式: 例如排序 传进来的比较器
  定义一个规则规范，在这个规范内的具体的实现是一种策略 ---理解的有歧义 设计模式多是多态的一种运用
  在坦克大战中 子弹的打出可以是一种策略  可以一次打出一个 多个 炮弹等等
  电脑坦克的产生是一种策略 一次出现几个

3.工厂系列 工厂方法 抽象工厂
  任何可以产生对象的方法或类 都可以称为工厂 单例也可以说是一种工厂 不可以咬文嚼字
  为什么有了new 还要有工厂？ 为了更灵活 产生对象交给工厂 定制可以更自由更灵活

  简单工厂:可以定制化创建对象 多个 public T createT(){}
  工厂方法:专门定制某一对象  只生产一种产品的抽象工厂
  抽象工厂: 定制化一系列对象的组合 一族 打包销售
  从语义上:属性抽象成接口 实物之类的抽象类比较好 名称抽象类 形容词接口

4.门面模式 由一个门面去协调所有的关系 当你想访问某一关系的时候 只需要访问门面就可以了
5.调停者模式 这些关系可能互相之间又要打交道 这时有一个关系专门处理关系之间的打交道
这两个模式----消息中间件 面板不和坦克 子弹 爆炸 墙等等其他物品直接联系 全部交给face门面处理
这些物品之间交互也不互相接触 全部交给gameObject处理 调停者模式
这样理解face相当于中间件 gameObject相当于消息 要互相接触时就仍一个gameObject消息到face
然后在消息的订阅方收到消息在自己处理

6.责任链模式 一个定义链里面元素的规则 一个链的对象 链可以实现里面元素的规则(也可以不实现 具体灵活运用)
如果有需要检测的元素 可以经过整个链的里面元素检测是否符合 可以自己定义是否停止 具体灵活运用
Filter 过滤器 拦截器都是这个模式灵活的运用

7.装饰者模式 装饰者包装某一个需要装饰的对象 然后需要装饰的对象还继续按照它以前的逻辑继续执行，不同的装饰器
装饰自己需要的东西 如果想装饰器之间也可以继续装饰 那装饰器和要装饰的对象有共同的父类