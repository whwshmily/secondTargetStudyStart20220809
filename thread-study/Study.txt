1 什么是进程
   进程是操作系统进行资源分配的基本单位。例如：你打开一个程序QQ 操作系统会先找到它的可执行文件 然后加载到内存中
   当程序进程要被执行时，被放进CPU中
2 什么是线程
  线程是程序执行的路径。如果你没有不同的执行路径 单线程
  多线程 一个程序进程产生不同的分支，分支在同时执行
  程序(进程)是以线程为单位开始执行的，当程序开始执行时，会先找到主线程(main方法)

  进程是资源分配的基本单位，线程是进行的调度执行的基本单位。多个线程共享进程的资源


  程序有指令 有数据
  CPU 包含 寄存器组存储数据register  计算单元ALU   PC寄存器用来存储执行哪条指令了
  OS操作系统 负责调度线程的执行
  当CPU执行某一进程时，如果要切换执行另一个进程 会把当前进程放入cache缓存中(进程的内存地址 执行到哪了)
  然后去执行另一进程  这就是进程之间的来回切换 OS负责调度 调度算法 CPU只管执行(不区分是哪个进程的)
  由OS进行调度

  一个CPU同一时间只能跑一个线程 问 单个CPU设置多线程是否有意义？ 进程并不是一直消耗CPU(等待输入指令 sleep)

  线程CPU密集型 大量计算 IO密集型 输入输出读写

  工作线程是否是越多越好 ？ 线程切换也消耗资源
  多少个最合适？ 方式一：核数 CPU个数 每一个核上都可以跑一个线程。当然机器上也有其他的线程要执行(其他程序 GC)
  所以核数也不一定是最优 不是占满是最合适的 要留一定空间处理紧急事情
  有一个公式 线程数量 = 核数*期望CPU利用率*(1+等待时间/计算时间)  CPU期望利用率0-1之间
  等待时间/计算时间 怎么知道等待时间和计算时间 只能部署之后 统计才能得到
  需要用到工具profiler计算

3 创建线程的5种方式
  继承Thread类 实现Runnable接口 实现callable接口(配合futureTask，或者线程池) 线程池  lambda表达式

4 线程的状态
  创建NEW  运行(就绪和运行) 阻塞 等待 超时等待 死亡TERMINATED
  运行种就绪是暂时让出了CPU 运行是正在执行 --running

  阻塞 发生枪锁的过程 没有拿到锁 被阻塞 类似进入等待队列 等待被吊起  --block 只有synchronized锁才会 lock不会
  因为lock锁底层是CAS 是一种忙等待

  等待 不是进入等待队列 忙等待 是park lock join  --wait 可以理解已经持有锁了 在等待
  timed waiting 类似于 sleep 到一定时间自动醒来   可以理解已经持有锁了 在等待

5 线程的打断interrupt
  interrupt() 不是打断线程 只是设置了一个标志位 看到这个标志位 做怎么处理由线程处理
  isInterrupted() 查询线程是否被打断过 查询标志位
  interrupted() 静态的  查询当前线程是否被打断过 重置标志位 查询当前标志位的值 并且把标志位值为false(重置标志位)
  让线程结束的一种方案 假如一个线程一直循环处理，然后每隔一段时间检测标志位是否结束

  sleep wait join 都会抛出interruptException异常 如果这时候进行interrupt 就会抛这个异常
  抛这个异常会复位标志位

  竞争锁的过程中synchronized lock也不会 不会被interrupt打断 这种要想打断锁的过程
  可以使用ReentrantLock.lockInterruptibly()这个

6 结束一个线程 优雅的结束  上传一个大文件 如果用户取消 怎么优雅打断
  stop方法已废弃 直接结束线程 不建议使用 容易产生数据不一致问题
  太粗暴 不管线程什么状态 直接结束 如果线程持有锁 他会直接释放锁 不管你在做什么
  suspend 方法 已废弃  暂停  和stop类似 持有锁 不会释放
  resume 方法 已废弃   继续  和stop类似 两个配合使用 产生死锁 或数据不一致
  线程外由volatile修改的标志位 线程根据这个标志位是否结束 有局限性 不依赖中间状态 相对优雅
  如果中间由wait 或者做添加删除等操作时 因为数据同步需要时间 外部变量变了 同步到线程内 可能线程已经由执行了一部分
  精确控制 很难 不依赖精确时间控制上面两个比较优雅
  interrupt 使用 和volatile类似 比volatile更加优雅一点 设置标志位
  不依赖精确时间精确控制上面两个比较优雅

7 并发变成三大特性 原子性 可见性 有序性