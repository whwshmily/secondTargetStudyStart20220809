范式: 三大范式 列不可分  完全依赖主键  不能依赖传递
第一范式：列的单元格不能在进行拆分
第二范式  每一列都完全依赖主键
第三范式：列与列之间没有相互依赖关系

inndb每次读取16kb的数据
索引的数据结构
哈希表-----适合等值匹配--不是和范围查找
b+树  --（其他树，数据量大树的结构深 io次数多）减少io

b树  ---》mysql 默认一层读取16kb  每一层存的是指针范围和数据
假设每一次读取三层  最大读取的数据量 就是16*16*16 因为存的数据占用大量的空间
b+树 只在叶子节点存数据 上面的节点只存储 指针 指向数据的位置 这样一下子就可以
读取更多的数据

B+树  左边的值一定比父节点小 右边的一定比父节点大或等于 高度相差不超过1
叶子节点相连 非叶子节点存的是索引 叶子节点存的数据
B树 节点存数据

索引的分类（给唯一键建立索引）
 主键
 唯一
 普通
 全文 innodb5.6以上支持
  组合

假设表没有主键 mysql 也会自动生成主键 rowId的索引

聚簇索引  主键 将表的主键建立B+树 叶子节点存的是整行的数据
非聚簇索引  叶子节点存的行数据的地址

只有主键的b+树才是存的整行 其他的索引都是存的主键id

辅助索引(二级索引) 存的行数据的地址 ---非聚簇索引

每一个辅助索引都会有一个B+树 都可能产生回表  如果使用组合索引可能会减少

回表:普通列的索引(非聚簇索引) b+树叶子节点存放的数据不是整行数据 存放的是主键索引，然后去查主键索引的b+树 查找整行数据

覆盖索引  例如 你查整行数据（通过普通索引）会产生回表，但是如果你只查id（因为普通索引存的是id直接返回） 这时候就不会回表 这时候就叫覆盖索引

组合索引 叶子节点存的是组合索引和主键  如果只查询索引字段和主键 也不会产生回表
先按第一个字段建立索引 后续相同的字段 下一次字段有序排列

自适应hash索引 当你的数据是热点数据 经常查询 mysql会建立hash索引提高效率 5.7版本默认开启
只能条件= in  可以使用
hash索引不能排序

前缀索引 类型为 varchar  blob text  取这些字段的前几个字节当作索引  不能排序和分组 和覆盖索引
会降低索引的选择行  取的前几个字段 要足够长 重复的不要太多 以区分
如果都是重复的 搜索的也会有问题

where条件中有多个索引 一般只会用到一个

索引: 索引列的字段类型尽量小
离散程度高 count(distinct 列)/count(*) 接近1 最好

页分裂：如果新增一条数据 b+树中的叶子节点存不下了，就会进行页分裂
页合并：如果删除一条数据 b+树有可能进行页合并

查询优化:
慢SQL mysql 执行时间大于这个参数 long_query_time  默认10S 会被记录下来
show variables like 'slow_query_log' 默认OFF

执行计划 explain
Id  select_type    table    type  possible_keys  key key_len rows extra

id决定表的读取顺序
id 相同  执行顺序从上到下  先加载哪张表  table字段 按顺序加载  等值查询
id不同 如果是子查询    id大的先执行 先加载  id越大优先级越大
id相同不同 同时存在    id越大优先级越高  相同按顺序执行    （子表 from 是select查询值做表）

select_type  常见的值  simple  primary  subquery  quriued  union （union result）
simple  查询中不包含子查询或者union
primary  查询中包含任何复杂的子部分  最外层查询别标记为   最后执行的（字查询先执行）
subquery  在select或where列表包含字查询  字查询中的查询的执行顺序
derived  在from中字查询（结果做表  的表）作为derived（衍生）MySQL 会递归执行这些字查询  把结果放在临时表中
union all  第二个select出现在union之后  则被标记为union  若union包含在from字查询中 外层的select被标记为derived
union result  是从union表中获取出来的select

type  最好到最次的顺序
system  const  eq_ref  ref  range  index all   一般能达到ragne  ref 就可以了

system  表中等于一行记录   等于系统表 const特例  单表单行就是这个
const  常量 主键     通过一次索引就找到了 const  用于比较primary key 或者unique索引  只匹配一行 很快  如果将主键置于where列表中 mysql就将该查询转化为一个常量
eq_ref   唯一索引扫描  对于每个索引键  表中只有一条记录与之匹配 常用于 主键或唯一索引扫描  表连接 通过主键或者二级索引
ref   非唯一索引   返回匹配某个单独值的所有行  本质上是一种索引访问  返回所有匹配某个单独值的行 可能会找到多个符合条件的行  属于查找和扫描的混合体
range   只检索给定范围的行  使用一个所有选择行  不用扫描全部     范围   条件列有索引
index  index 只遍历索引树  通常比all快
all  全表扫描
null  极端情况


优化：
 最左匹配 中间不能断 可以不按顺序写 MySQL会优化 第一个肯定要有 要不然用不到索引
 不要在索引列上进行计算 函数 类型转换 之后会使索引失效（这一次列会使用索引码，不知道，应该会）
 尽量使用主键查询，不是其他索引 这样不会触发回表查询
 使用前缀索引 --索引是很长的字符串，这样会使索引很大且慢 可以使这一列前几个字符作为索引  不支持order by  group by
 使用索引扫描来进行排序
 union all in or 都能使用索引 但是推荐使用in
 范围查找之后 不会使用索引（组合索引） 范围字段之后的索引字段 用不上了 里面的值已经乱序了 根据B+树的存储
 != 会使索引失效
 is null is not null 可能索引失效
 like   后面%会使用索引 开头%索引失效(如果覆盖索引也会使用)
 排序要小心 不要 asc desc 混用 排序列不包含一个索引列 有多个索引列 不能使用索引
 强制类型转换会全表扫描
 更新十分频繁 数据区分度不高的不适合建立索引 （一般可以使用count(dictinct(列))/count(*)>0.8）
 创建索引的列 不允许为null 可能得到不符合预期的结果
 最好不要连接超过三张表 最好关联字段的类型一致 join 字段最好是索引列
 如果明确知道只有一个返回结果 limit可以提高效率（因为检索会依次查找 即使你只有一个 他也会判断要有没有 继续查找，但是写limit就不会判断了）
 单表索引最好控制5个以内
组合索引列最好不要超过5个

count(*)/count(1) 统计为空的 count(列) 不统计为空的
varchar 会保留空格 char会去除空格t

truncate删除表中的内容，不删除表结构，释放空间；delete删除内容，不删除表结构，但不释放空间。
truncate删除数据后重新写数据会从1开始，而delete删除数据后只会从删除前的最后一行续写；内存空间上，truncate省空间。
truncate是直接从1开始，即全部清空开始，而delete需要先得到当前行数，从而进行续写；所以truncate删除速度比delete快
delete是DML语句,不会自动提交。drop/truncate都是DDL语句,执行后会自动提交

查询优化
 1分析查询慢的原因  --网络 CPU  io 上下文切换 系统调用 生成统计信息 锁等待时间（innodb锁的是索引）
 2优化数据访问 ---访问的数据太多，可以减少访问数据量的方式（如果你只需几条，看rows是否是5）
  是否向数据库请求不需要的数据---查询不需要的数据， 多表查询返回所有的列（假如你不需要全部）
3执行过程的优化
 4优化特定类型的查询

执行过程的优化：
 查询缓存
 查询的优化处理（查询sql，mysql会解析sql，预处理，优化sql）-- 语法解析器和预处理和查询优化器
 语法解析器和预处理：MySQL通过关键字将sql语句解析，并生成一个解析树
 查询优化器：语法解析器之后--目的选择最有效的执行方式
    MySQL有可能选择错误的执行计划（统计信息不准确，执行计划成本不等于实际执行成本等等）
    优化器优化策略： 静态--直接对解析器优化  动态---与查询的上下文有关 取值 索引对应的行数有关 （静态只需要一次，动态每次都需要重新预估）
    优化器优化类型： 重新定义关联表的顺序（a join b join c  不一定先读取哪张表）
                                内连接的效率高于外连接的效率（内连接获取的数据量少于外连接）
                            //    等价变换原则（例如a！=4 ===> a>4 || a<4）
                                优化count min max（最好带上分组条件用上索引效率会更高）
                                索引的覆盖扫描 当索引的列包含查询需要的列的时候 可以使用覆盖索引
                               子查询优化（如经常查询的数据可以放入缓存中）就是这条字查询（连接的表或表）的结果别频繁使用放入缓存中
                               等值传播  如果两个列的值通过等式连接，那么MySQL能够把其中一个列的where条件传递到另一个上 就是两张表连接 a.id = b.id where a.id >100  where条件可以换成 b.id>100
    排序优化：排序算法： 两次排序：第一次数据读取时将需要排序的字段读取出来然后进行排序 第二次将拍好序的结果按照需求去读取数据行（会随机io）
                                      单次排序：一下读取查询所有列 然后在根据排序的字段进行排序
                           当需要排序的列总大小加上order by 的列大小超过max_length_for_sort_data 定义的字节会使用双次排序
                            可以设置参数值来选择排序的方式



事务：ACID 原子性 一致性  隔离性 持久性
原子性：要成功都成功 要失败都失败
一致性：一致性基于原子性 例如转账，账户总金额是不变的
隔离性：事务互不干扰 4个 seri （都可以避免）可重复读 （避免脏读 不可重复读） 读已提交 避免脏读 读未提交（都解决不了）
持久性：事务一旦提交 对数据进行改变，是永久性不可逆的

seri都可以
可重复读：可以避免  脏读 不可与重复读
读已提交: 可以避免脏读
读未提交: 都避免不了

脏读：读到别人没有提交的数据
不可重复读：多次读同一份数据，别的事务对他进行修改 ，读到的结果不一致  行锁可以解决
幻读：多次读同一份数据，别的事务对他进行新增 删除 ，读到的结果不一致   表锁可以解决

保存点
隐式提交 : DDL语句 创建表 修改属性 索引等等 就会提交事务 在一个事务中再次开启一个事务 前一个事务会被提交

版本链
readview select语句会生成一个

共享锁 和 排他锁
共享锁  后面加 lock in share mode
排他锁  后面加 for update

锁的力度 行锁 和 表锁
意向锁:解决加锁效率问题  表锁要确定有没有被加锁 判断当前时间有没有锁
表锁 lock tables 表名 read
行锁 lock tables 表名 write

where 条件上是索引 才是行锁 否则是表锁 for update  只有索引才是行锁
执行计划上explain 真正使用到索引
行锁是通过索引加锁实现的，只有通过索引检索条件，才会使用行锁，否则使用表锁
表锁期间，别人不能加锁

innodb  默认使用
myisam
区别            innodb   myisam
事务支持     1 支持     0不支持
数据行锁定   1             0
外键              1             0
全文索引          0           1
表空间的大小    较大 2倍    较小

元数据锁 DDL语句

间隙锁的危害 范围条件    符合条件但没有的记录也会锁定   锁定范围  在范围内不存在也锁住



隐藏索引 不会被使用 不会删除 只是不可见 可以通过参数设置使用隐藏索引 --灰度发布
降序索引 innodb支持 索引默认是升序的
函数索引 --Mysql实现 增加一个列 用户不可见



索引合并:通过使用多个索引来完成一次查询
intersection合并 普通索引要等值匹配才能使用 主键可以范围
union合并
sort-union合并

连接查询
驱动表只遍历一次


页-->16kb
区-->64页
断--256区

双写机制



