git 位置  https://github.com/whwshmily/algorithms
二进制逻辑运算
&   与       遇0则0   1&1=1 1&0=0 0&1 = 0 0&0=0
|     或       遇1则1   1|1 = 1  1|0=1  0|1 = 1  0|0 =0
~   反       1-0  0-1  取反
^   异或    不进位加（相同0 不同1）1^1=0 0^0=0 1^1=0 1^0=1 (记住 加法 不进位  1+1 = 0（不进位）)
两个相同的数异或=0  0异或N=N
同样一批数异或的结果一样 不管顺序

>> 右移    补符号位  0000 1011---》 1000 0101 （符号位是1补1 符号位是0 补0 ） （对于正整数是除2）
<<  左移   补0   永远补0  （对于正整数是乘2）2的三次方-----》2<<2  | 1<<<3
 >>>   无符号右移    补0

一个int类型的数 找到他最右侧的1 N&(~N+1)


整形 int  表示范围 二的31次方-1  这个是只占用了31位  最前面的32位 用来表示符号 0是非负数 1是负数
所以int的范围是 负的二的31次方到 二的31次方-1
负数是 正数的取反+1 然后32位为1  为什么？ 是为了底层运算(+-*/)的时候一套逻辑 不用区分

一个数的相反数 ： 前面直接- 或 取反+1

数据结构 ：连续结构(数组) 跳转结构(链表)  连续+跳转(map)

数组： 方便查找 寻找容易 增加删除 难
跳转： 增加删除 简单 寻址难

Math.Random() 返回的是一个double类型的 范围是[0,1) 出现的概率是相等的
(int)(Math.random()*8) 表示0-7整数 中的任意一个数出现的概率是相同的

等差数列求和
常数操作：操作和数据没关系 时间一定 例如 int相加 数组寻址 时间复杂度 O1
时间复杂度：就关心最高阶的 例如冒泡排序经过的次数是等差数列求和 最高阶为n的二次方 估计用最差的情况
所以冒泡排序的时间复杂度o的n二次方
时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。
使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况

常见的时间复杂度有：常数阶O (1),对数阶O (log2n),线性阶O (n), 线性对数阶O (nlog2n),平方阶O (n2)，
立方阶O (n3),...， k次方阶O (nk),指数阶O (2n)

位运算的速度 要比+-*/速度快的多


链表问题 --- 注意要确认头部 还有需要一个自己操作的节点变量
栈和队列可以用双向链表实现---NodeCode1 NodeCode2
栈 从头部加节点 从头部出 /或从尾部加节点 从尾部出
队列 从头部加节点 从尾部出 /或从尾部加节点 从头部出
数组实现 固定大小 --动态另说
栈 添加数据直接添加 有一个index标记 加一个数 index++  取数的取index-1位置
队列--成环 四个变量 size 数组里面存在变量的数量 limit 数组的容量 pollIndex 取数的index  pushIndex 添加的index
当size=0 没数据 不能取 size==limit 满了不能在存了  取数的时候先取数然后pollIndex+1 到达数组边界归0 同理pushIndex

NodeCode3
栈实现队列 两个栈 push栈 pop栈 push添加数据 取数据的时候 把push的栈的数据全部导入pop栈里面然后从pop栈里面取数据
导数据的时候 pop栈一定要是空的 否则有问题

队列实现栈 两个队列 data队列 help队列 压入数据的时候压入data 取数的时候 先把data队列前面的数压入help队列
最后一个数弹出 不压 然后data队列变成help help变成data

ArrCode
怎么求数组L-R范围的最大值 递归 --- 数组分为两部分 每一部分求一个最大值 这两个比较得到最大值

任何递归行为都可以改成非递归行为


归并排序---mergeSort ---适用场景 纠结某一个数左边比你大或小 | 纠结某一个数右边比你小或大 都可以用归并的思想处理
mergeSort 处理

compareTo 排序是字典序
比较字符串 如果是等长的 比较第一个字母
不一样长的 短的后面补齐  补最小的  然后比较

二叉树:---TreeNode1
先序  头左右 每一颗子树都满足 先打印 头 左  右  第一次经过这个节点
中序  左头右  第二次经过这个节点
后续  左右头  第三次经过这个节点
递归序 任何节点都经过三次

非递归实现，栈实现 队列 TreeNode2

子树:从头节点出发，下面的都要

完全二叉树 一棵深度为k的有n个结点的 二叉树 ，对树中的结点按从上至下、从左到右的顺序进行编号，
从左到右都是满的,或者最深的那一层不是满的，但是是从左到右依次满的也是完全二叉树

堆是完全二叉树
大根堆 --任何一个节点的数最大值都是他的父节点--所有大的值在顶部
小根堆 --任何一个节点的数最小值都是他的父节点--PriorityQueue就是小根堆--可以传入比较器变成大根堆
？？？记堆的数组规律
堆排序--数组中的数先加入到PriorityQueue中依次弹出就可以了

前缀树:--PrefixTree
单个字符串中,字符从前到后的加到一颗多叉树上
字符放在路上,节点上有专属的数据项 pass 和end
所有样本都这样添加,没有路就新建,有路就复用
沿途节点的pass值加1,每个字符串结束时来到的节点end值加1

桶排序--是一种思想 计数排序就是桶排序 缺点 必须要和样本的数据相关强依赖 对数据本身有要求
不基于比较的排序 计数排序---
基数排序--非负且十进制 ---RadixSort

---不基于比较的排序 对样本有极高的要求 不易改写
基于比较的排序 时间的复杂的极限是O(N*logN)
为了绝对速度选快排 稳定性选归并 空间复杂度最小选堆排序

稳定性？
快慢指针: --QuickAndSlowPoint
输入链表头节点,奇数长度返回中点,偶数长度返回上中点
输入链表头节点,奇数长度返回中点,偶数长度返回下中点
输入链表头节点,奇数长度返回中点前一个,偶数长度返回上中点前一个
输入链表头节点,奇数长度返回中点前一个,偶数长度返回下中点前一个

环线链表找到相遇的点---RingProblem
给定两个可能有环也可能无环的链表，头节点head1 head2
如果两个链表相交请返回第一个节点 没有返回null

单链表不告诉头节点 只告诉其中的节点然后删除 ？缺点
获取下一节点的值 让自己变成下一节点的值 然后指向下一节点的下一节点
如果删除的是最后一个节点 这种就操作不了

求树的最大宽度 -- map--不用---WidthTree

按层打印二叉树--LayerTree

二叉树的序列化---不要忽略空节点 -先序中序后序序列化和按层序列化---SerializationTree

如何打印一棵树 ---图形化 输出--GraphicsPrintTree

//TreeNode3
树 节点右三个指针 左 右 父 告诉其中一个节点 返回后继节点--中序打印的下一个节点
前驱节点 中序的前一个节点

折纸条 第一次折纸 出现一个凹折痕 再次对折 就会在这个折痕的上方出现一个凹折痕 下方出现一个凸折痕
再次对折会在上一次出现的所有折痕上方出现一个凹折痕 下方出现一个凸折痕
按照顺序打印折痕----不建立树--OrigamiT


二叉树的递归套路:
1.假设以X节点为头，假设可以向X左树和X右树要任何信息
2.在上一步的假设下，讨论以X为头节点的树,得到的答案的可能性-最重要
3.列出所有可能性后，确定到底需要向左树和右树要什么样的信息
4.把左树信息和右树信息求全集，就是任何一颗子树都需要这样放回的信息S
5.递归函数都返回S，每一颗子树都这么要求
6.写代码，在代码中考虑如何把左树的信息和右树的信息整合成整棵树的信息

2.可能性常见的分析 和X有关 和X无关


平衡二叉树:在一颗二叉树中每一颗子树的左树高度和右树的高度，高度差不超过1
搜索二叉树，左树都比我小 右树都比我大 没有重复 所有的子树都满足 SearchTree
满二叉树 所有节点都是满的

求一棵树是不是平衡二叉树--给头节点--BalanceTree
求一个树任何两个节点都存在距离，整棵树的最大节点 --距离 从这个节点到另一个节点需要经过的节点数--MaxRangeTree
给定一个二叉树head 返回这个树最大二叉搜素树的节点数--MaxSearchTree
给定一个二叉树head 返回这个树最大二叉搜素树头节点--MaxSearchTree
派对的最大的快乐值--MaxHappyTree
员工的定义 class Employee{int happy ; list<Employee> subordinate//这个员工的直属下级}
一个员工只有一个直接上级 可以有多个直接下级
员工来了 他的直接下级都不能来--求快乐的最大值

二叉树是不是满二叉树 给头节点 --FullTree
求一个数是不是完全二叉树 两种方法 一种递归 一种非递归 IsComTree

给定一个二叉树的头节点，和另外两个节点 返回  a和b最低公共祖先 往上面找最先遇到的父类 两种方式--FirstCommonFatherNode

贪心算法: 小根堆和大根堆和排序处理 最常用
最自然智慧的算法
用一种局部最功利的标准，总是做出在当前看来最好的选择
难点在于最证明最功利的标准得到全局最优解
对于贪心算法的学习主要以增加阅历和经验为主

给定一个字符串数组 ，要求数组里面的元素拼接成一个字符串 要求字典序最小

一些项目要占用会议室，给以项目的开始时间和结束时间 返回最多的宣讲场次

给定一个字符串由 X和.组成
X代表墙 不可以放灯 不被点亮
. 可以放灯和点亮  一盏灯可以照亮他本身和前后的.
问放多少盏灯可以全部点亮所有的.

分金条
分一块金条 分成多少长度的需要多少铜板
给定一个数组 [10,20,30]  表示 60长度的金条 分给三个人 10 20 30 长度
例如 先分成 10 50 长度 需要60铜板  50再分成 20 30 需要50 铜板 一共需要110铜板
问最少代价----哈夫曼树


给定一组项目 利润[] 花费[] 和初始资金 i 最多能做几个项目K
问最后得到的金额最大

并查集--节点往上找的过程 把链变成扁平化  小集合挂大集合  方法O(1)
给定一系列样本 a b c d e f g 类型假设V
并查集认为每个样本都在单独的集合里
用户可以在任何时候调用下面两个方法
boolean isSameSet(V x,V y) 查询样本X和Y是否在一个集合
void union(V x,V y) 把x和y所在的集合合并成一个集合
isSameSet和union方法代价越低越好
--user有三个属性 只要有一个属性相同 就认为是同一个对象 求有多少个user

暴力递归

图
由点的集合和边的集合组成 存在有向图和无向图的概念 实际上都是向有向图表达 边上可能带有权值

图的宽度优先遍历(同一层的顺序无所谓) 深度优先遍历

最小生成树算法---不破坏连通性 权值最小
kruskal---并查集
总是从权值最小的边开始考虑 依次到权值最大的bian
当前的边要么进最小生成树的集合 要么丢弃
当前的边进入最小生成树的集合 如果形成环就丢弃 否则加入

从最小权值的开始考虑  如果这两个点不在并查集 加入集合 合并并查集
重复操作

prim算法
随便一个点 找到这个点的所有边 找到最小权值的边 ，加入到集合
然后到最小权值的这个点的所有边 找到里面最小权值的 加入到集合 如果集合里面有不处理
重复

dijkstra算法 要求权值不为负 出发点到所有的点的距离和最小是多少
这个点到所有的点的最小距离是什么  到不了的位置是正无穷

暴力递归---所有的尝试过程---找到这个很关键,后续动态规划
把问题转化为缩小的小问题
找到不需要继续进行递归的条件 base case  终止条件
得到子问题的结果之后的决策过程
不记录每一个子问题的解

汉诺塔问题 最优步数 2^n -1 次
有三个柱子 柱子上有N个圆盘 每个圆盘不一样大  从上往下依次增大
移动时没有盘子的柱子可以移动随意大小的圆盘，有圆盘的，小的圆盘一定要在大的圆盘上面
问 左侧柱子上所有的圆盘移动到最右面需要的最小步数


给你一个栈 请你逆序这个栈 不能申请额外的数据结构,只能使用递归

打印一个字符串的所有的字串和子序列 例如 abc a ab  abc b bc -字串 连续
子序列-可以不连续 相对次序不能乱 例如 abc a ab ac abc b bc
打印全部子序列，并且不出现重复字面值的子序列 ---子序列里面不能有重复的
打印一个字符串的全排列 和 不能出现重复的

--可以改成动态规划
从左往右尝试模型1 规定A对应1 B对应2 C对应3
给定一个数字字符串 "111 可以装换为 AAA KA AK
给定一个数字字符串有多少中转换结果

--可以改成动态规划
给定两个长度为N数组  重量和价值
给定一个正整数bag 表示一个袋子 装过的重量不能超过这个袋子
问可以装的最大价值是多少

--可以改成动态规划
给定一个整形数组arr，代表数值不同的纸牌排成一条线，玩家A和玩家B依次拿走每张纸牌
规定A先拿 B后拿
但是每个玩家每次只能拿走最左或最右的牌
请返回最后获胜者的分数

N*N的棋盘上 要摆放N个皇后
要求任何两个皇后 不同行 不同列 也不在同一条斜线上
给定一个正整数N 返回N皇后有多少种摆法
摆不了的返回0

--可以改成动态规划
假设有排成一行的N个位置，几位1~N N一定大于或等于2
开始机器人在其中M位置上  M一定在1-N之间
如果机器人来到1位置，那么下一步只能往右到2的位置
如果到N位置  那么下一步只能到N-1
如果到中间可以往左或往右
规定机器人必须走K步，最终能来到P位置的方法有多少种

动态规划: 动态规划都来源与暴力递归,暴力递归有重复解--可以使用动态规划
可变参数的选择
常见的四种模型:从左往右的尝试模型,范围上的尝试模型,多样本位置全对应的尝试模型,寻找业务限制的尝试模型
最糙的记忆化搜索  加入缓存 重复的从缓存种拿取
记忆化搜索做精细化组织--就是经典动态规划
暴力递归使用递归进入后里面有重复解---把这一些列组合缓存起来
有重复计算的过程，把这些可变参数变成结构化缓存结构
有暴力递归的出口，生成那些不知道位置的值(生成结构化的缓存结构)，直接返回正确的结果--不需要递归

有一个正整数数组无重复，数组里面的值代表货币，每一个值都可以使用多次
给定一个钱数，问有多少种

有后效性和无后效性
无后效性是动态规划算法及贪心算法的前提条件
无后效性：某阶段的状态一旦确定，则此后过程的决策不再受此前各种状态及决策的影响。
有后效性：就是某个状态之后要做的决策会受之前的状态及决策的影响

枚举行为优化:预处理数组,斜率优化,四边形不等式

给定一个字符串str,给定一个字符串类型的数组arr
arr里面的每一个字符串代表一张贴纸,你可以把单个字符剪开使用目的是拼出str
每一张贴纸可以使用多次
返回需要至少多少张贴纸可以完成这个任务--不是几种
例子 str="babac",arr={"ba","c","abcd"}
至少需要两张贴纸 "ba","abcd" 使用这两个 把每一个字符串单独剪开使用，含有两个a 2个b 1个c可以拼出 返回2


什么暴力递归可以继续优化?
有重复调用同一个子问题的解,这种递归可以优化
如果每一个子问题都是不同的解,无法优化也不用优化

暴力递归和动态规划的关系
某一个暴力递归,有解的重复调用,就可以把这个暴力递归优化成动态规划
任何动态规划问题,都一定对应着某一个有解的重复调用的暴力递归
不是所有的暴力递归,都一定对应着动态规划


如何找到某个问题的动态规划
设计暴力递归,分析有没有重复解 套路解决--有没有重复解，可以列出调用的步骤
用记忆化搜索---用严格表结构实现动态规划--套路解决
看能否继续优化

两个字符串公共子序列问题---子序列可以看上面的题目

给定一个数组,代表每个人喝完咖啡准备刷杯子的时间---有序的，无序的情况下要先排序
只有一台咖啡机，一次只能洗一个杯子，时间耗费a,洗碗才能洗下一杯
每个咖啡也可以自己挥发干净,时间耗费b,咖啡可以并行挥发
让咖啡杯变干净的完成最早时间
三个参数 int[]arr int a int b
感觉和从左往右很像 挥发or洗---做决定吗

常见的4种尝试模型
从左往右---背包问题
范围上---纸牌问题
多样本位置全对应--两个字符串公共子序列问题
寻找业务限制--洗咖啡










